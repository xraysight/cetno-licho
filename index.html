<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Licho Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* CSS Styles */

        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            text-align: center;
            margin: 0;
            padding: 0;
            color: #fff;
        }

        h1 {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 4vw;
            color: #fff;
            text-shadow: 2px 2px 5px #000;
        }

        .controls {
            margin: 20px;
        }

        .controls button {
            font-size: 1em;
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(45deg, #555, #777);
            color: #fff;
            box-shadow: 2px 2px 5px #000;
            cursor: pointer;
        }

        .controls button:hover {
            background: linear-gradient(45deg, #777, #999);
        }

        /* Disable the difficulty button when inactive */
        .controls button:disabled {
            background: #333;
            cursor: not-allowed;
            color: #777;
        }

        #gameStatus {
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px #000;
        }

        #gameBoard {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 2px;
            max-width: 90vw;
            max-height: 58vh; /* Adjusted to fit within the viewport */
            aspect-ratio: 6 / 7; /* Maintains the board's aspect ratio */
            margin: 0 auto 20px auto;
            background-color: #1e1e1e; /* Match this to your page background color */
        }

        .cell {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: pointer;
            background: #2b2b2b;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 2px 2px 5px #000, inset -2px -2px 5px #444;
            transition: background-color 0.3s;
        }

        .cell.blocked {
            background: transparent;
            cursor: default;
            box-shadow: none;
            pointer-events: none;
            border: none;
        }

        .cell.valid::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 128, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 128, 255, 0.7);
            pointer-events: none;
        }

        .cell .number {
            font-size: 2.5em;
            color: #fff;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: none;
        }

        /* Styles for player cells */
        .cell.player1 {
            background-color: green;
        }

        .cell.player2 {
            background-color: red;
        }

        #winnerMessage {
            color: #ffbf00; /* Amber color */
            text-transform: uppercase;
            text-shadow: 2px 2px 5px #000;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            overflow: auto;
            z-index: 1000;
        }

        #helpContent {
            background: #1e1e1e;
            padding: 20px;
            width: 90%;
            max-width: 600px;
            margin: 100px auto;
            text-align: left;
            border-radius: 10px;
            color: #fff;
            box-shadow: 0 0 20px #000;
        }

        #helpContent h2 {
            text-align: center;
            margin-top: 0;
            text-shadow: 2px 2px 5px #000;
        }

        #helpContent p {
            font-size: 1.2em;
        }

        #helpContent button {
            display: block;
            margin: 20px auto 0 auto;
            font-size: 1.2em;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(45deg, #555, #777);
            color: #fff;
            box-shadow: 2px 2px 5px #000;
            cursor: pointer;
        }

        #helpContent button:hover {
            background: linear-gradient(45deg, #777, #999);
        }

        .hidden {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 6vw;
            }

            .controls button {
                font-size: 1em;
                padding: 8px 16px;
            }

            #gameStatus {
                font-size: 1.5em;
            }

            .cell .number {
                font-size: 2em;
            }

            #helpContent p {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <h1>Licho Game</h1>

    <div class="controls">
        <button id="playerToggle">Player 2: Human</button>
        <button id="difficultyButton" disabled>Difficulty: Easy</button>
        <br>
        <button id="helpButton">Help</button>
        <button id="resetButton">Reset</button>
        <button id="randomizeButton">Random Board</button>
    </div>

    <div id="gameStatus"></div>

    <div id="gameBoard"></div>

    <div id="overlay" class="hidden">
        <div id="helpContent">
            <h2>How to Play Licho</h2>
            <p>
                - The game is played on a 6x7 grid (6 columns and 7 rows).<br>
                - Some cells are blocked and cannot be used.<br>
                - Player 1 starts by placing the number 1 on any unblocked cell.<br>
                - Players take turns placing the next number on an adjacent cell.<br>
                - You can only place a number if there is an odd number of already numbered neighboring cells.<br>
                - The game ends when a player cannot make a move.<br>
                - The last player to make a valid move wins.<br>
                - Use the "Random Board" button to start a game with random blocked border cells.<br>
                - When playing against the computer, you can switch difficulty between Easy and Normal.
            </p>
            <button id="closeHelp">Close</button>
        </div>
    </div>

    <script>
        // JavaScript Code

        const gameBoard = document.getElementById('gameBoard');
        const gameStatus = document.getElementById('gameStatus');
        const playerToggle = document.getElementById('playerToggle');
        const resetButton = document.getElementById('resetButton');
        const helpButton = document.getElementById('helpButton');
        const randomizeButton = document.getElementById('randomizeButton');
        const overlay = document.getElementById('overlay');
        const closeHelp = document.getElementById('closeHelp');

        let board = [];
        let currentPlayer = 1;
        let moveNumber = 1;
        let lastMove = null;
        let gameActive = true;
        let isPlayer2Computer = false;
        let difficulty = 'Easy'; // 'Easy' or 'Normal'

        const ROWS = 7; // 7 rows vertically
        const COLS = 6; // 6 columns horizontally

        // Default blocked cells coordinates
        const defaultBlockedCells = [
            [0, 4], [0, 5],
            [6, 5],
            [6, 0], [6, 1], [5, 0]
        ];

        // Current blocked cells used in the game
        let blockedCells = [...defaultBlockedCells];

        // Initialize the game
        function initGame(useDefaultBlockedCells = true) {
            board = [];
            gameBoard.innerHTML = '';
            moveNumber = 1;
            currentPlayer = 1;
            lastMove = null;
            gameActive = true;
            gameStatus.textContent = `Player ${currentPlayer}'s turn`;

            // Use default blocked cells or keep the current ones
            if (useDefaultBlockedCells) {
                blockedCells = [...defaultBlockedCells];
            }

            createBoard();
            updateValidMoves();
        }

        // Create the game board
        function createBoard() {
            for (let row = 0; row < ROWS; row++) {
                board[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    // Check if cell is blocked
                    if (isCellBlocked(row, col)) {
                        cell.classList.add('blocked');
                        board[row][col] = 'blocked';
                    } else {
                        board[row][col] = null;
                        cell.addEventListener('click', cellClicked);
                    }

                    gameBoard.appendChild(cell);
                }
            }
        }

        // Check if a cell is blocked
        function isCellBlocked(row, col) {
            return blockedCells.some(coord => coord[0] === row && coord[1] === col);
        }

        // Handle cell click
        function cellClicked(e) {
            if (!gameActive) return;

            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);

            if (isValidMove(row, col)) {
                makeMove(row, col);
                if (gameActive) {
                    switchPlayer();
                    updateValidMoves();
                    if (currentPlayer === 2 && isPlayer2Computer) {
                        setTimeout(computerMove, 500);
                    }
                }
            }
        }

        // Make a move
        function makeMove(row, col) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            cell.classList.remove('valid');
            cell.removeEventListener('click', cellClicked);

            const numberElement = document.createElement('div');
            numberElement.classList.add('number');
            numberElement.textContent = moveNumber;
            cell.appendChild(numberElement);

            // Add the player-specific class to the cell
            cell.classList.add(currentPlayer === 1 ? 'player1' : 'player2');

            board[row][col] = {
                player: currentPlayer,
                number: moveNumber
            };

            lastMove = { row, col };
            moveNumber++;
        }

        // Switch player
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            gameStatus.textContent = `Player ${currentPlayer}'s turn`;
        }

        // Update valid moves
        function updateValidMoves() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('valid');
            });

            let hasValidMoves = false;

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] === null && isValidMove(row, col)) {
                        const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                        cell.classList.add('valid');
                        hasValidMoves = true;
                    }
                }
            }

            if (!hasValidMoves) {
                gameActive = false;
                gameStatus.innerHTML = `<div id="winnerMessage">PLAYER ${currentPlayer === 1 ? 2 : 1} WINS!</div>`;
            }
        }

        // Check if a move is valid
        function isValidMove(row, col) {
            if (board[row][col] !== null) return false; // Correctly excludes occupied and blocked cells
            if (lastMove === null && moveNumber === 1) return true;

            if (!isAdjacent(row, col, lastMove.row, lastMove.col)) return false;

            const neighbors = getNeighbors(row, col);
            const numberedNeighbors = neighbors.filter(n => {
                const cellValue = board[n.row][n.col];
                return cellValue !== null && cellValue !== 'blocked';
            });
            if (numberedNeighbors.length % 2 !== 1) return false;

            return true;
        }

        // Check if two cells are adjacent
        function isAdjacent(row1, col1, row2, col2) {
            return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1;
        }

        // Get neighboring cells
        function getNeighbors(row, col) {
            const neighbors = [];
            for (let r = row - 1; r <= row + 1; r++) {
                for (let c = col - 1; c <= col + 1; c++) {
                    if (
                        r >= 0 && r < ROWS &&
                        c >= 0 && c < COLS &&
                        !(r === row && c === col)
                    ) {
                        neighbors.push({ row: r, col: c });
                    }
                }
            }
            return neighbors;
        }

        // Computer's move
        function computerMove() {
            if (difficulty === 'Easy') {
                computerMoveEasy();
            } else {
                computerMoveNormal();
            }
        }

        // Easy difficulty: Random move
        function computerMoveEasy() {
            const validMoves = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (isValidMove(row, col)) {
                        validMoves.push({ row, col });
                    }
                }
            }

            if (validMoves.length > 0) {
                const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                makeMove(move.row, move.col);
                if (gameActive) {
                    switchPlayer();
                    updateValidMoves();
                }
            }
        }

        function computerMoveNormal() {
            const validMoves = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (isValidMove(row, col)) {
                        validMoves.push({ row, col });
                    }
                }
            }

            // First, try to find a winning move (after which Player 1 has no valid moves)
            for (let move of validMoves) {
                // Clone the board and simulate the move
                const boardClone = JSON.parse(JSON.stringify(board));
                boardClone[move.row][move.col] = {
                    player: 2,
                    number: moveNumber
                };
                const lastMoveClone = { row: move.row, col: move.col };
                const moveNumberClone = moveNumber + 1;

                // Check if Player 1 has any valid moves after this move
                const playerValidMoves = getAllValidMoves(1, lastMoveClone, boardClone, moveNumberClone);
                if (playerValidMoves.length === 0) {
                    // Winning move found
                    makeMove(move.row, move.col);
                    if (gameActive) {
                        switchPlayer();
                        updateValidMoves();
                    }
                    return;
                }
            }

            // Second, try to find a move where, after any of Player 1's moves, the computer still has valid moves
            for (let move of validMoves) {
                // Clone the board and simulate the move
                const boardClone = JSON.parse(JSON.stringify(board));
                boardClone[move.row][move.col] = {
                    player: 2,
                    number: moveNumber
                };
                const lastMoveClone = { row: move.row, col: move.col };
                const moveNumberClone = moveNumber + 1;

                // Get all possible moves for Player 1 after this move
                const playerValidMoves = getAllValidMoves(1, lastMoveClone, boardClone, moveNumberClone);

                let computerHasResponse = true;

                for (let playerMove of playerValidMoves) {
                    // Simulate Player 1's move
                    const boardClone2 = JSON.parse(JSON.stringify(boardClone));
                    boardClone2[playerMove.row][playerMove.col] = {
                        player: 1,
                        number: moveNumberClone
                    };
                    const lastMoveClone2 = { row: playerMove.row, col: playerMove.col };
                    const moveNumberClone2 = moveNumberClone + 1;

                    // Check if computer has any valid moves after Player 1's move
                    const computerResponseMoves = getAllValidMoves(2, lastMoveClone2, boardClone2, moveNumberClone2);
                    if (computerResponseMoves.length === 0) {
                        computerHasResponse = false;
                        break;
                    }
                }

                if (computerHasResponse) {
                    // Found a move where the computer will have valid moves after any of Player 1's moves
                    makeMove(move.row, move.col);
                    if (gameActive) {
                        switchPlayer();
                        updateValidMoves();
                    }
                    return;
                }
            }

            // If no such move is found, make a random move
            computerMoveEasy();
        }

        // Get all valid moves for a player given a board state
        function getAllValidMoves(player, lastMoveParam, boardParam, moveNumberParam) {
            const validMoves = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (boardParam[row][col] === null && isValidMoveSimulation(row, col, player, lastMoveParam, boardParam, moveNumberParam)) {
                        validMoves.push({ row, col });
                    }
                }
            }
            return validMoves;
        }

        function isValidMoveSimulation(row, col, player, lastMoveSim, boardSim, moveNumberSim) {
            if (boardSim[row][col] !== null) return false; // Correctly excludes occupied and blocked cells
            if (lastMoveSim === null && moveNumberSim === 1) return true;

            if (!isAdjacent(row, col, lastMoveSim.row, lastMoveSim.col)) return false;

            const neighbors = getNeighbors(row, col);
            const numberedNeighbors = neighbors.filter(n => {
                const cellValue = boardSim[n.row][n.col];
                return cellValue !== null && cellValue !== 'blocked';
            });
            if (numberedNeighbors.length % 2 !== 1) return false;

            return true;
        }
        
        // Generate random blocked cells on the border
        function generateRandomBlockedCells() {
            const borderCells = [];

            // Top and bottom borders
            for (let col = 0; col < COLS; col++) {
                borderCells.push([0, col]); // Top border
                borderCells.push([ROWS - 1, col]); // Bottom border
            }

            // Left and right borders (excluding corners to prevent duplicates)
            for (let row = 1; row < ROWS - 1; row++) {
                borderCells.push([row, 0]); // Left border
                borderCells.push([row, COLS - 1]); // Right border
            }

            // Randomly select 6 unique border cells
            const shuffled = borderCells.sort(() => 0.5 - Math.random());
            blockedCells = shuffled.slice(0, 6);
        }

        // Event listeners
        playerToggle.addEventListener('click', () => {
            isPlayer2Computer = !isPlayer2Computer;
            playerToggle.textContent = `Player 2: ${isPlayer2Computer ? 'Computer' : 'Human'}`;

            // Enable or disable the difficulty button
            difficultyButton.disabled = !isPlayer2Computer;

            if (!gameActive) {
                initGame();
            }
        });

        resetButton.addEventListener('click', () => initGame(true));

        helpButton.addEventListener('click', () => {
            overlay.classList.remove('hidden');
        });

        closeHelp.addEventListener('click', () => {
            overlay.classList.add('hidden');
        });

        randomizeButton.addEventListener('click', () => {
            generateRandomBlockedCells();
            initGame(false);
        });

        difficultyButton.addEventListener('click', () => {
            difficulty = difficulty === 'Easy' ? 'Normal' : 'Easy';
            difficultyButton.textContent = `Difficulty: ${difficulty}`;
        });

        // Start the game
        initGame();
    </script>
</body>
</html>
